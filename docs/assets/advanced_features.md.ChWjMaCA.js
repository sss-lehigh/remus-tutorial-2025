import{_ as a,c as o,o as n,j as e,a as r}from"./chunks/framework.Cf11ooiF.js";const f=JSON.parse('{"title":"Advanced Remus Features","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"advanced_features.md","filePath":"advanced_features.md"}'),i={name:"advanced_features.md"};function s(d,t,u,c,l,h){return n(),o("div",null,t[0]||(t[0]=[e("h1",{id:"advanced-remus-features",tabindex:"-1"},[r("Advanced Remus Features "),e("a",{class:"header-anchor",href:"#advanced-remus-features","aria-label":'Permalink to "Advanced Remus Features"'},"â€‹")],-1),e("p",null,"In the landing page for this tutorial, you might have noticed a link to the Remus API documentation. If you dig through it, or look at the Remus code, you will discover some performance-enhancing features that were not discussed in this tutorial. They include:",-1),e("ul",null,[e("li",null,"Lightweight threads for increasing concurrency without incurring high context switching overheads (fibers)."),e("li",null,"Techniques for avoiding copying of data when reading from and writing to the distributed memory (zero copy)."),e("li",null,"Support for asynchronous reading and writing, where a thread can issue a remote memory operation, continue executing, and periodically poll to see if the memory operation completed.")],-1),e("p",null,"If time permits, you should try to use some of these features, along with some good old fashioned hand-tuning of your code. You should be able to increase throughput by at least a factor of two, and maybe more!",-1)]))}const p=a(i,[["render",s]]);export{f as __pageData,p as default};
