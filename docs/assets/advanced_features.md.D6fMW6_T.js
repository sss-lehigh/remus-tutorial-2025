import{_ as o,c as n,o as r,j as e,a as t}from"./chunks/framework.Cf11ooiF.js";const f=JSON.parse('{"title":"Advanced Remus Features","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"advanced_features.md","filePath":"advanced_features.md"}'),i={name:"advanced_features.md"};function s(d,a,u,c,l,h){return r(),n("div",null,a[0]||(a[0]=[e("h1",{id:"advanced-remus-features",tabindex:"-1"},[t("Advanced Remus Features "),e("a",{class:"header-anchor",href:"#advanced-remus-features","aria-label":'Permalink to "Advanced Remus Features"'},"â€‹")],-1),e("p",null,"In the landing page for this tutorial, you might have noticed a link to the Remus API documentation. If you dig through it, or look at the Remus code, you will discover some performance-enhancing features that were not discussed in this tutorial. They include:",-1),e("ul",null,[e("li",null,"Techniques for avoiding copying of data when reading from and writing to the distributed memory (zero copy)."),e("li",null,"Support for asynchronous reading and writing, where a thread can issue a remote memory operation, continue executing, and periodically poll to see if the memory operation completed."),e("li",null,[t("Lightweight threads for increasing concurrency without incurring high context switching overheads (fibers) ("),e("strong",null,"coming soon"),t(").")])],-1),e("p",null,"If time permits, you should try to use some of these features, along with some good old fashioned hand-tuning of your code. You should be able to increase throughput by at least a factor of two, and maybe more!",-1)]))}const p=o(i,[["render",s]]);export{f as __pageData,p as default};
